from __future__ import annotations
import os
import logging
import json
import comfy.hooks
import comfy.utils
import folder_paths


class MultiScheduledLoraLoader:
    """
    ============================================================================
    NODE DEFINITION & INPUT CONFIGURATION
    ============================================================================
    Defines the ComfyUI node interface. Accepts a hidden JSON configuration
    string from the custom UI widget, an optional external schedule string
    (for text-based automation), and previous hooks for chaining.
    """

    @classmethod
    def INPUT_TYPES(s):
        return {
            "required": {
                "schedule_config": (
                    "STRING",
                    {"default": "[]", "multiline": False, "forceInput": False},
                ),
            },
            "optional": {
                "previous_hooks": ("HOOKS",),
                "schedule_string": ("STRING", {"forceInput": True, "multiline": True}),
            },
        }

    RETURN_TYPES = ("HOOKS", "STRING")
    RETURN_NAMES = ("HOOKS", "schedule_string")
    FUNCTION = "process"
    CATEGORY = "advanced/hooks/scheduling"

    """
    ============================================================================
    FILE SYSTEM UTILITIES
    ============================================================================
    Helper methods to resolve LoRA file paths. Includes logic to search through
    the ComfyUI LoRA directory structure to find files by name, handling
    subdirectories and supported PyTorch extensions.
    """

    def get_lora_path(self, lora_name):
        return folder_paths.get_full_path("loras", lora_name)

    def find_lora_path_by_name(self, sanitized_name: str) -> str | None:
        lora_folders = folder_paths.get_folder_paths("loras")
        for lora_folder in lora_folders:
            for root, _, files in os.walk(lora_folder, followlinks=True):
                for file in files:
                    if os.path.splitext(file)[0] == sanitized_name:
                        if any(
                            file.lower().endswith(ext)
                            for ext in folder_paths.supported_pt_extensions
                        ):
                            full_path = os.path.join(root, file)
                            return os.path.relpath(full_path, lora_folder)
        return None

    """
    ============================================================================
    SCHEDULE PARSER
    ============================================================================
    Parses the input schedule data into a standardized dictionary format.
    It supports three input types:
    1. A raw JSON list (generated by the UI widget).
    2. A legacy 9-part string format.
    3. A modern compact 4-part string format.
    """

    def parse_schedule_string(self, input_string):
        lora_list = []
        if not input_string:
            return []

        input_string = input_string.strip()
        if not input_string:
            return []

        if input_string.startswith("["):
            try:
                return json.loads(input_string)
            except Exception as e:
                logging.error(f"JSON parse failed, trying string format. Error: {e}")

        lines = input_string.split("\n")
        for line in lines:
            line = line.strip()
            if not line.startswith("<lora:") or not line.endswith(">"):
                continue

            content = line[6:-1]
            parts = content.split(":")

            lora_name_in = parts[0]
            lora_path = self.find_lora_path_by_name(lora_name_in)
            if not lora_path:
                lora_path = lora_name_in

            try:
                item = {
                    "lora_name": lora_path,
                    "strength_model": float(parts[1]),
                    "strength_clip": float(parts[2]),
                    "points": [],
                }

                if len(parts) == 4:
                    points_str = parts[3]
                    point_pairs = points_str.split(";")
                    for pair in point_pairs:
                        if "," in pair:
                            px, py = pair.split(",")
                            item["points"].append({"x": float(px), "y": float(py)})

                elif len(parts) == 9:
                    s_start = float(parts[3])
                    s_end = float(parts[4])
                    p_start = float(parts[6])
                    p_end = float(parts[7])
                    count = int(parts[8])

                    for i in range(count):
                        t = i / (count - 1) if count > 1 else 0.0
                        x = p_start + (p_end - p_start) * t
                        y = s_start + (s_end - s_start) * t
                        item["points"].append({"x": x, "y": y})

                else:
                    continue

                lora_list.append(item)
            except Exception as e:
                logging.error(f"Error parsing schedule line '{line}': {e}")

        return lora_list

    """
    ============================================================================
    MAIN EXECUTION LOGIC
    ============================================================================
    The core processing method. It prioritizes internal JSON config over external
    strings. For each LoRA, it generates hooks and text representations,
    combines them with previous hooks, and manages history concatenation.
    """

    def process(self, schedule_config, schedule_string=None, previous_hooks=None):
        active_loras = []

        internal_loras = []
        if schedule_config and schedule_config != "[]":
            internal_loras = self.parse_schedule_string(schedule_config)

        external_loras = []
        if schedule_string:
            external_loras = self.parse_schedule_string(schedule_string)

        is_using_external_as_active = False

        if internal_loras:
            active_loras = internal_loras
        elif external_loras:
            active_loras = external_loras
            is_using_external_as_active = True

        current_node_hooks = []
        current_node_text_lines = []

        def fmt(val):
            return f"{float(val):.4f}".rstrip("0").rstrip(".")

        for item in active_loras:
            lora_name = item.get("lora_name")
            if not lora_name:
                continue

            try:
                s_model = float(item.get("strength_model", 1.0))
                s_clip = float(item.get("strength_clip", 1.0))
                points = item.get("points", [])

                if points:
                    points.sort(key=lambda p: p["x"])
                    clean_name = os.path.splitext(os.path.basename(lora_name))[0]
                    points_str = ";".join(
                        [f"{fmt(p['x'])},{fmt(p['y'])}" for p in points]
                    )
                    line = (
                        f"<lora:{clean_name}:{fmt(s_model)}:{fmt(s_clip)}:{points_str}>"
                    )
                    current_node_text_lines.append(line)
            except Exception as e:
                logging.warning(
                    f"Error generating schedule string for {lora_name}: {e}"
                )

            lora_path = self.get_lora_path(lora_name)
            if not lora_path:
                logging.warning(f"LoRA not found: {lora_name}")
                continue

            lora = comfy.utils.load_torch_file(lora_path, safe_load=True)

            if s_model == 0 and s_clip == 0:
                continue

            hook = comfy.hooks.create_hook_lora(
                lora=lora, strength_model=s_model, strength_clip=s_clip
            )

            if points:
                hook_kf = comfy.hooks.HookKeyframeGroup()
                for i, p in enumerate(points):
                    percent = float(p["x"])
                    strength = float(p["y"])
                    guarantee_steps = 1 if i == 0 else 0

                    hook_kf.add(
                        comfy.hooks.HookKeyframe(
                            strength=strength,
                            start_percent=percent,
                            guarantee_steps=guarantee_steps,
                        )
                    )
                hook.set_keyframes_on_hooks(hook_kf=hook_kf)

            current_node_hooks.append(hook)

        final_hook_list = []
        if previous_hooks is not None:
            final_hook_list.append(previous_hooks)

        final_hook_list.extend(current_node_hooks)

        if not final_hook_list:
            combined_group = comfy.hooks.HookGroup()
        else:
            combined_group = comfy.hooks.HookGroup.combine_all_hooks(final_hook_list)

        current_text_block = "\n".join(current_node_text_lines)
        final_string = ""

        if is_using_external_as_active:
            final_string = current_text_block
        else:
            if schedule_string:
                final_string = f"{schedule_string}\n{current_text_block}".strip()
            else:
                final_string = current_text_block

        return (combined_group, final_string)
